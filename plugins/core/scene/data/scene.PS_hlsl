cbuffer PerApplication : register(b0)
{
    matrix p;
	matrix lightProjection;
}

cbuffer PerFrame : register(b1)
{   
    matrix v;   
	matrix lightView;

    float3 lightColor;
	float3 lightDir;
}

cbuffer PerObject : register(b2)
{
    matrix m;
    matrix anti_m;

	bool hasLight;
	bool hasTexture;
	bool hasDistanceField;
}

Texture2D tex : register(t0);
Texture2D shadowDepthMap : register(t1);

SamplerState texSampler : register(s0);
SamplerState clampSampler : register(s1);

struct PixelShaderInput {
    float4 position : SV_POSITION;
    float4 color : COLOR;
    float4 worldPos : POSITION;
    float3 normal : NORMAL;
    float2 uv : TEXCOORD0;
	float4 lightViewPosition : TEXCOORD1;
};

float median(float r, float g, float b) {
    return max(min(r, g), min(max(r, g), b));
}

float4 main(PixelShaderInput IN)
    : SV_TARGET
{
    float4 colorAcc = IN.color;

	if (hasTexture){
		if (hasDistanceField){
			float2 msdfUnit = 4.0/float2(512.0, 512.0);
			float4 sample = tex.Sample(texSampler, IN.uv);
			float sigDist = median(sample.r, sample.g, sample.b) - 0.5;
			//sigDist *= dot(msdfUnit, float2(0.5));
			sigDist *= 4.0;
			float opacity = saturate(sigDist + 0.5);
			colorAcc = lerp(float4(0,0,0,0), colorAcc, opacity);
		}
		else
		{
			colorAcc = colorAcc * tex.Sample(texSampler, IN.uv);
		}
	}
	
	if (hasLight){
		float bias = 0.001f;
		float2 lightTexCoord;
		lightTexCoord.x = IN.lightViewPosition.x / IN.lightViewPosition.w / 2.0 + 0.5;
		lightTexCoord.y = -IN.lightViewPosition.y / IN.lightViewPosition.w / 2.0 + 0.5;

		float shadowDepth = shadowDepthMap.Sample(clampSampler, lightTexCoord).r;
		float lightDepth = IN.lightViewPosition.z / IN.lightViewPosition.w;
		lightDepth = lightDepth - bias;

		float ambientStrength = 0.4;
		float3 ambient = ambientStrength * lightColor;

		float3 diffuse = float3(0,0,0);

		if (lightDepth < shadowDepth){
			float diffuseStrength = 0.7;
			float3 norm = normalize(IN.normal);
			float diff = max(dot(norm, -lightDir), 0.0);
			diffuse = diffuseStrength * diff * lightColor;
		}

		colorAcc = float4(ambient + diffuse,1.0) * colorAcc;
	}

    return colorAcc;
}