cbuffer PerApplication : register(b0)
{
    matrix p;
}

cbuffer PerFrame : register(b1)
{   
    matrix v;   

    float3 lightColor;
	float3 lightDir;
}

cbuffer PerObject : register(b2)
{
    matrix m;
    matrix anti_m;
}

cbuffer PerObject : register(b3)
{
    matrix bones[32];
}

struct AppData {
#ifdef HAS_POSITION0
    float3 aPos : POSITION0;
#endif
#ifdef HAS_POSITION1
    float2 aPos2 : POSITION1;
#endif
#ifdef HAS_COLOR0
    float4 aColor : COLOR;
#endif
#ifdef HAS_NORMAL0
    float3 aNormal : NORMAL;
#endif
#ifdef HAS_TEXCOORD0
    float2 aUV : TEXCOORD;
#endif
#ifdef HAS_BONEINDICES0
	int4 aBoneIDs : BONEINDICES;
#endif
#ifdef HAS_WEIGHTS0
	float4 aWeights : WEIGHTS;
#endif
};

struct VertexShaderOutput {
    float4 position : SV_POSITION;
    float4 color : COLOR;
    float4 worldPos : POSITION;
    float3 normal : NORMAL;
    float2 uv : TEXCOORD;
};

VertexShaderOutput main(AppData IN)
{
    VertexShaderOutput OUT;

#ifdef HAS_POSITION1
    float2 aPos2 = IN.aPos2;
#else
    float2 aPos2 = float2(0,0);
#endif

#ifdef HAS_BONEINDICES0
	matrix BoneTransform = bones[IN.aBoneIDs[0]] * IN.aWeights[0]
	+ bones[IN.aBoneIDs[1]] * IN.aWeights[1]
	+ bones[IN.aBoneIDs[2]] * IN.aWeights[2]
	+ bones[IN.aBoneIDs[3]] * IN.aWeights[3];
	OUT.worldPos = mul(m, mul(BoneTransform, float4(IN.aPos, 1.0)));
#else
	OUT.worldPos = mul(m, float4(IN.aPos, 1.0));
#endif
    
    OUT.position = mul(p, mul(v, OUT.worldPos + float4(aPos2, 0.0, 0.0)));
    OUT.position.z += OUT.position.w;
    OUT.position.z /= 2;
    
#ifdef HAS_COLOR0
    OUT.color = IN.aColor;
#else
    OUT.color = float4(1,1,1,1);
#endif
#ifdef HAS_NORMAL0
	OUT.normal = mul((float3x3)anti_m, IN.aNormal);
#else
    OUT.normal = float3(0,0,0);
#endif
#ifdef HAS_TEXCOORD0
	OUT.uv = IN.aUV;
#else
    OUT.uv = float2(0,0);
#endif

    return OUT;
}
