#version 300 es

precision highp float;

uniform PerApplication
{
	mat4 p;	
	mat4 lightProjection;
};

uniform PerFrame
{
	mat4 v;
	mat4 lightView;

	vec3 lightColor;
	vec3 lightDir;
};

uniform PerObject
{
	mat4 m;
	mat4 anti_m;

	bool hasLight;
	bool hasTexture;
	bool hasDistanceField;
	bool hasSkeleton;
};

uniform SSBO_Info 
{
	uint SSBO_Offsets[1];
};

uniform SSBO
{
	vec4 SSBO_data[128];
};

mat4 getBone(int index){
	uint index0 = uint(4 * index) + SSBO_Offsets[0];
	return mat4(
		SSBO_data[index0],
		SSBO_data[index0 + uint(1)],
		SSBO_data[index0 + uint(2)],
		SSBO_data[index0 + uint(3)]
	);
}


layout(location = 0) in vec3 aPos;
layout(location = 1) in vec2 aPos2;
layout(location = 2) in vec4 aColor;
layout(location = 3) in vec3 aNormal;
layout(location = 4) in vec2 aUV;
layout(location = 5) in ivec4 aBoneIDs;
layout(location = 6) in vec4 aWeights;

out vec4 color;
out vec4 worldPos;
out vec3 normal;
out vec2 uv;
out vec4 lightViewPosition;


void main()
{
	if (hasSkeleton){
		mat4 BoneTransform = getBone(aBoneIDs[0]) * aWeights[0]
		+ getBone(aBoneIDs[1]) * aWeights[1]
		+ getBone(aBoneIDs[2]) * aWeights[2]
		+ getBone(aBoneIDs[3]) * aWeights[3];
		worldPos = m * BoneTransform * vec4(aPos, 1.0);
	}else{
		worldPos = m * vec4(aPos, 1.0);
	}
    gl_Position = p * (v * worldPos + vec4(aPos2, 0.0, 0.0));	
	gl_Position.y *= -1;

    color = aColor;
	normal = mat3(anti_m) * aNormal;
	uv = vec2(aUV.x, aUV.y);
	lightViewPosition = lightProjection * (lightView * worldPos + vec4(aPos2, 0.0, 0.0));
}